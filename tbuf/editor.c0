/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2025                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Augment doubly linked lists with row and column information.
 *
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct editor_header editor;
struct editor_header {
  tbuf* buffer;
  int row;
  int col;
};

bool is_editor(editor* E);

editor* editor_new();                  /* Creates a new, empty text buffer */
void editor_forward(editor* E);        /* Moves the cursor forward (right) */
void editor_backward(editor* E);       /* Moves the cursor backward (left) */
void editor_insert(editor* E, char c); /* Insert a character before cursor */
void editor_delete(editor* E);         /* Remove character before cursor   */
void editor_up(editor* E);             /* Moves the cursor up              */
void editor_down(editor* E);           /* Moves the cursor down            */

/*** Implementation ***/

/********************* WRITE YOUR CODE BELOW THIS LINE *********************/
bool is_editor(editor* E)
{
  return E != NULL && is_tbuf(E->buffer) &&
         tbuf_row(E->buffer) == E->row &&
         tbuf_col(E->buffer) == E->col;
}

editor* editor_new()
//@ensures is_editor(\result);
{
  editor* E = alloc(editor);
  E->buffer = tbuf_new();
  E->row = 1;
  E->col = 0;
  return E;
}

void editor_forward(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (!tbuf_at_right(E->buffer)) {
    if (E->buffer->cursor->data == '\n') {
      E->row ++;
      E->col = 0;
    } else {
      E->col ++;
    }
    tbuf_forward(E->buffer);
  }
}

void editor_backward(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (!tbuf_at_left(E->buffer)) {
    tbuf_backward(E->buffer);
    if (E->buffer->cursor->data == '\n') {
      E->row --;
      E->col = tbuf_col(E->buffer);
    } else {
      E->col --;
    }
  }
}

void editor_insert(editor* E, char c)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  tbuf_insert(E->buffer, c);
  if (c == '\n') {
    E->row ++;
    E->col = 0;
  } else {
    E->col ++;
  }
}

void editor_delete(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (!tbuf_at_left(E->buffer)) {
    char c = tbuf_delete(E->buffer);
    if (c == '\n') {
      E->row --;
      E->col = tbuf_col(E->buffer);
    } else {
      E->col --;
    }
  }
}

// Bonus: Implement these function if you do the bonus task
void editor_up(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (E->row == 1) return;
  int targRow = E->row - 1;
  int targCol = E->col;
  while (!(E->row == targRow && E->col == targCol)) {
    editor_backward(E);
    if (E->buffer->cursor->data == '\n' && E->col < targCol)
      return;
  }
}

bool last_row(editor* E)
{
  int currRow = E->row;
  int step = 0;
  while (E->row == currRow) {
    if (tbuf_at_right(E->buffer)){
      for (int i=0; i<step; i++) editor_backward(E);
      return true;
    }
    editor_forward(E);
    step ++;
  }
  for (int i=0; i<step; i++) editor_backward(E);
  return false;
}

void editor_down(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (last_row(E)) return;
  int targRow = E->row + 1;
  int targCol = E->col;
  while (!(E->row == targRow && E->col == targCol)) {
    editor_forward(E);
    if (E->row == targRow && 
        (E->buffer->cursor->data == '\n') || tbuf_at_right(E->buffer))
      return;
  }
}
